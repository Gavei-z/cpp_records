# C++ malloc/free (内存管理第三章)

管理内存的意义：为了可以收回来很快，也为了可以消除碎片。

以下讨论：第一次申请内存大小为256字节的情形：

<img src="C++ mallocfree (内存管理第三章).assets/image-20230613232954789.png" alt="image-20230613232954789" style="zoom:67%;" />

C++程序调用前后，会有一些动作。写的main函数在上图第八步。上图称作：call stack（调用的次序，调用的栈）。CRT: C Run Time

从上图中右图可见：`_heap_alloc_base`为小区块（3F8，1016）服务。VC6下的复杂的内存管理是应付小区块的。

<img src="C++ mallocfree (内存管理第三章).assets/image-20230614001942857.png" alt="image-20230614001942857" style="zoom: 33%;" />

在VC10（新版本）下，看起来不再为小区块进行服务，通通都交给操作系统来进行。但其实这些都放在OS层面去了。

<img src="C++ mallocfree (内存管理第三章).assets/image-20230614002739511.png" alt="image-20230614002739511" style="zoom:50%;" />

`_heap_init`初始化，将16个header准备好。（新版和旧版都是这样的操作）

一个header长这样：

<img src="C++ mallocfree (内存管理第三章).assets/image-20230614003103635.png" alt="image-20230614003103635" style="zoom: 50%;" />

-----

----

所有通过malloc申请的内存，都会被链表给管理起来，即使这一块已经给你了，也在SBH的管理下（除了申请到的空间外，还多分配了一些额外的内存空间）。

<img src="C++ mallocfree (内存管理第三章).assets/image-20230615001906265.png" alt="image-20230615001906265" style="zoom:50%;" />

上述操作完后，需要调整为16的倍数。因为：算法设计不可能为每种内存大小进行服务，所以要调整为指定的大小区块。

<img src="C++ mallocfree (内存管理第三章).assets/image-20230615002634231.png" alt="image-20230615002634231" style="zoom: 50%;" />

所以，在申请内存的时候：会有一些头尾额外的cookie来进行填补。上图：当第一次申请256（0x100）字节空间，需要加上：上面给调试器用的一些区块32，加上下面的4字节额外空间（这个空间用来判断是否越界），再加上头尾两个cookie => 0x100 + 0x20 + 0x4 + 4 * 2 = 0x12C，然后再调整为16的倍数 => 0x130。**16的倍数最后一位一定是0**

继续上例：上下cookie会继续申请的空间有多大，为什么是131？它借用了最后一位bit是否为1来代表此块内存是否分配了出去。在将来，此块内存还给SBH的时候，最后一位bit又会被改为0。

从`_ioinit()`一直到`_sbh_alloc_block`一直在计算真正的区块的大小，还没开始分配内存。

----

<img src="C++ mallocfree (内存管理第三章).assets/image-20230615232533429.png" alt="image-20230615232533429" style="zoom:67%;" />

我对上图的指针指向并不是很懂，为什么这个指针经过了两次的封装定义？为什么两根指针都指向同一个地方？

### 分配、第一刀

64组指针中：第一组负责16大小的分配，第二组负责32大小的分配... 最后一组负责大于等于1k大小的分配。

重申：用户申请一定大小的空间，这个大小会被调整，会加：header、cookie，然后再调整为16的倍数。

<img src="C++ mallocfree (内存管理第三章).assets/image-20230615235923971.png" alt="image-20230615235923971" style="zoom:50%;" />

​	

剪刀处：红色的地址传出去，131代表：空间大小为130，末尾加1代表已经分配了出去。切割：cookie的调整，然后将首地址传出去。

返回给用户的地址空间大小还是当时申请的时候的大小。

上图："ioinit.c"下的81代表是文件中81行发出的请求，2代表是给CRT用的（c run time）

题外话：如果在main函数的右括号结束之前，将内存管理链表走一遍，发现有属于_NORMAL_BLOCK的内存块，那就是内存泄漏。
